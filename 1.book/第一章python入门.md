# 第一章python入门

## 1. python 概述

### 1.1 python解释器

Python在形式上是一个解释性语言，命令在一系列的python解释器中执行。解释器先收到一个命令，后执行该命令，最后返回命令的结果。一个基本的程序首先要定义一系列的命令，保存这些命令在纯文本文件中作为资源代码或脚本，然后解释器就可以与其交互（尤其是在debug的时候）

### 1.2 python程序预览

Python语法很大程度上依赖于空格的使用。单独的命令会重新使用另一行进行描述。尽管一个命令可以延续到另一行，但需要符号(\)进行连接，或者是没有闭合的括号。

在python中，空格也是控制语法结构的关键。尤其是一个缩进作为控制代码结构的一部分，内在的控制结构使用大量的缩进。在代码片段1.1中，while循环结构由8行命令构成，包括嵌套的循环结构。

在代码中对人类读者提供注释，需要忽略掉python解释器。在python中使用# 符号，可以写注释。

  Codefragment 1.1      page   25 

## 2 python对象

Python是一个面向对象语言，python类构成所有的数据类型。在这一部分，我们描述python面向对象中主要的方面，主要去介绍python的内置类，比如，：int 整形、float 浮点型、str 字符串。

### 2.1 标示符、对象和赋值语句

Python命令中最重要的就是赋值语句，例如：

temperature= 98.6

在这个命令中建立了一个temperature的标示符，然后把他关联到对象（等号右边）上，在这个例子中，这个浮点型对象的值是98.6.。描述这个任务的结果在下图。                         

![1](E:\github\data-structure\1.book\1.png)

**标示符：**

标示符在python中对大小写是非常敏感的，所以temperature和Temperature是两个不同的名字。标示符能由字母、数字和_(下划线)组成，但首字节不能由数字开始，并且由33各特殊的已保存单词，不能作为标示符。

![](E:\github\data-structure\1.book\2.png)

对于读者熟悉的其他编程语言来说，python标示符的语法与Java或C++在引用变量上市非常相似的。每一个标示符都有一个内存地址指向一个对象。Python标示符有一个特殊的对象None，与Java和C++里面的null类似。

与Java和C++不同的是，python是一个动态类型的语言，所以一个标示符连接诶一个数据类型时不需要提前声明。一个标示符能指定任何类型的对象，并且她能去指定另一个相同或者不同的类型。尽管一个标示符不需要声明类型，但对象本身需要定义类型。

可以有两个不同的标示符指向同一个对象，一个标示符的对象发生变化并不会影响另一个标示符。例如：

​         original = temperature

 ![3.](E:\github\data-structure\1.book\3..png)

​         temperature =temperature + 5.0

 ![4](E:\github\data-structure\1.book\4.png)

 

### 2.2 创造和使用对象

创建一个类的新实例的过程教实例化。通常，对于一个实例对象的语法就是去调用类的构造函数。

**(这中间很多我都看看过很多次了就没有继续翻译)**




### 1.8 迭代器和生成器

在1.4.2章节中，我们介绍了for循环语句，起始句：

```forelement in iterable:```

我们知道在python中有很多类型的对象都是克迭代的。基础的迭代容器像：list、tuple和set。而且，一个字符串的字节是可以迭代的，字典的key是可以迭代的，文件的每一行也是可以迭代的。用户自定义的类型也能支持迭代。在python中，迭代的机制是基于下列的及格约定：

- 1.迭代器是一个对象，管理着迭代的一系列的值。如果变量i标示一个迭代器对象，然后每个调用内部函数，下一个（i），从基础系列生成后续元素，伴随着一个停止迭代异常提出没有后续元素。

- 2.可迭代是一个对象，通过语法iter（obj）生成迭代器。

通过这些定义，列表是可迭代的，但它本身不是一个迭代器。对于with=【1，2，3，4】，调用next（with）是不合法的。可是一个迭代器对象可以用语法生成，i = iter(data)，每一次向下调用next（i）将会返回这个列表的元素。在python中for循环语法这个过程能很简单的自动匹配，为这个可迭代对象创造一个迭代器。重复的调用下一个元素直到捕获停止迭代异常。

一般的说，相同的可迭代对象，很有可能创造多重迭代器，每一个迭代器维持他自己的进程状态。可是，迭代器通常间接引用原始的元素集合维持他的状态。例如，调用iter（data）一个列表生成一个列表迭代器的。这个迭代器不能储存他自己的元素。相反，他将当前索引保存到列表当中，表示下一次迭代出现的对象。因此，如果在迭代器构造之后想修改迭代器的内容，但是在这之前迭代对象是完整的，迭代器将更新这个列表的内容。

Python也支持函数和类生成一系列值得隐式可迭代对象。起初不会构造一个数据结构去存储所有的值。例如，调用range（100000）不会返回数的列表；返回的是迭代对象的一个范围。作为需要，这个对象一次生成百万个值1.。像惰性计算技术有很大的优点。在范围内，允许for I in range(1000000)这样形式的循环，执行不需要内存储存这百万个值。像这样的循环也可能以某种形式被打断，不能计算该范围未使用的时间。

我们知道惰性计算用语python的许多方面。例如：字典类支持key、value、item方法。它们分别生成一个字典中所有键、值或（键、值）对的“视图”。这些方法生成了明确的结果的列表。视图的生成是基于字典的实际内容的可迭代对象。通过将迭代作为参数调用列表类构造函数，可以立即构造出这样一个迭代的显式的值列表。例如，list（range（1000））这个语法能生成一个值从0-999的列表内容。然而list(d.value())这个语法能生成字典d的当前值的元素的一个列表。在上面给的迭代方法，我们都能构造一个元祖或者集合实例。

**生成器**

在2.3.4节中，我们将解释怎样定义一个类让其实例作为一个迭代器。在python中创造迭代器最简单的方法是使用生成器。完成一个生成器的语法是与函数非常相似的，但不是返回值，是指示着一系列值得一个yield声明。例如：100有因数1，2，4，5，10，20，25，50，100.一个普通的函数可能生成并返回所有因数的列表。像这样：

```
def factors(n):
    results = []
        for k in range(1,n+1):
            if n%k == 0:
                results.append(k)
            return results
```

相反的，计算这些因数的生成器是这样完成的：

```
def factors(n):
    for k  in range(1,n+1):
        if n%k == 0:
            yield k
```

注意：现实结果使用的是yield而不是return。这在python中表明我们定义的是生成器而不是一个传统函数。在一些实现过程中结合yeild和return语句是不合理的，而不是返回一个空值导致生成器停止执行。如果写一个像for factor in factor(100)这样的循环语句。对于循环的每一次迭代，python执行我们的过程直到yield声明指到下一个值。在那时，这个程序被临时打断。只有需要下一个值时，才会被恢复。当控制流程到我们过程的结尾时，停止迭代异常会自动的出现。尽管在资源代码中这个例子只使用了单个yield声明，在由基本的控制语句决定的系列。一个迭代器能依靠多个yield声明在不同的结构中。例如：我们提高求n的因子的生成器的效率时，只是通过值得平方是否大于这个数，然后联系到到每一个k与n//k。如下，完成这个生成器：

```
def factors(n):
    k = 1
    while k*k < n:
        if n%k == 0:
            yield k
            yield n//k
        k+=1
    if k*k -== n:
        yield k
```

我们应该注意到这个生成器与第一个版本的生成器是不同的，他并不是一个严格的递增序列。

### 1.9 python 额外机制

这些语法提供了一些功能，可以使用我们之前介绍的功能来实现这些功能。可是，有时，这次新的语法是更整洁并且逻辑更加清晰的。

#### 1.9.1条件表达式

Python支持条件表达语法，去代替简单的控制结构。基本的语法表达式：

```expr if condition else expr2```

如果满足条件，这个值是expr，否则，值为expr2.这与Java与C++很相似。

返回绝对值n的例子（不依靠abs函数），使用传统的控制结构，我们这样完成：

```
if n>0:
    parm = n
else:
    param = -n
result = foo(param)
```

这个条件语法，我们能直接的赋值给变量param：

```
param = n if n>=0 else -n
result = foo(param)
```

事实上，这不需要赋多个表达式对一个变量。在函数中，条件表达式本身就可以作为参数。像这样：

```result = foo(n if n>=0 else -n)```

有时，他的优点仅仅是使代码更简洁。由于它避免了分散和复杂的控制结构。我们推荐条件表达是是因为他提高了代码的可读性，当两个选项中第一个更简单的情况下，才会使用表达式，因为他在语法中很突出。

#### 1.9.2 理解语法

一个非常常见的程序任务就是一系列的值运行在一系列的过程当中。在python中使用语法理解完成任务会非常简单。我们先介绍列表的理解，因为这是python支持的第一种形式。他的形式通常是这样的：

```[expression for value in iterable if condition]```

注意到表达式和条件可能都依赖于值，而if语句是可选的。理解的评估在逻辑上是与结算列表结果的传统控制结构是相等的。

```
result = []
for value in iterable:
    if condition
        result.append(expression)
```

计算数字从1到n的平方并储存在一个列表中。可以传统的语法像这样：

```
squares = []
for k in range(1,n+1):
    squares.append(k*k)
```

使用列表语法，逻辑表达式是这样的：

```
squares = [k**k for k in range(1,n+1)]
```

第二个列子，在1.8节中介绍的求一个数n的因数列表，这个任务可以像下面这样完成：

```factors = [k for k in range(1,n+1)if n%k == 0]```

Python支持相似的语法结构，分别生成一个集合、生成器、字典。我们对比以下生成数的平方的各种语法：

```[k*k for k in range(1,n+1)]  #列表```
```{k*k for k in range(1,n+1)}  #列表```
```(k*k for k in range(1,n+1))  #列表```
```{k:k*k for k in range(1,n+1)}  #列表```

当结果不需要储存在内存中时，生成器语法就会变得特别有吸引力。

1.9.3 循序填充或拆装序列

Python提供的两个附加的便利涉及到元组和其他序列的处理。第一个是修饰性的。在一个很大的内容下，如果一系列的表达式是通过逗号分隔开的。他们将会被作为一个单独的元组，即使没有圆括号提供。例如：

```data = 2,3,4,5```

Data的标示符分配成元组（2，3，4，5）这个行为叫自动包装元组。在python中函数返回多个值时常用这种包装。如果函数本身执行这种命令，

```return x,y```

它将自动的返回乘一个元组对象（x，y）。

对于包装行为的双重作用，python能自动的解压。允许一系列的单独的标示符对一个序列的元素。例如，我们能写分类的结果为a=7,b=8,c=9,d=10.通过调用的范围返回序列里的四个值。

```a,b,c,d = range(7,11)```

在这个语法中，右边的表达式式可迭代的类型，并且左边的变量数与右边的可迭代的元素数相同。

这个技术可以使用在函数返回值的元组。例如：内置函数divmod(a,b)，返回两个与整数除法的商和余数，(a//b,a%b)。尽管这个返回值是一个单一的元组，它也可以分开的两个标识符，这个语法他也可以与for循环混合使用，

```q,r = divmod(a,b)```

就像这样：

```for x,y in[(7,2),(5,8),(6,4)]```

在这个例子中，这个循环有三个迭代对象，这种使用键值对的类型在循环是非常常见的，她是通过字典类的items（）方法返回键值对。

```for k,v in mapping.items()```

同步分配：

同步分配工作是结合了自动打包和拆包的一项技术，我们明确的把一系列值分配给一系列的标示符，使用算法：

```x,y,z = 6,2,5```

事实上，右边的会自动分配给一个元组，然后自动拆分他的元素分配到左边的三个标示符。

当使用同步分配时，分配之前，等号右边的会匹配给等号左边的变量。对于将换两个变量提供了很便利的方法：

```j,k = k,j```

在这个命令下，j将会分配到k原来的值，k将得到j原来的值。在没有同步分配的时候，一个交换需要临时变量的调用。例如：

```
temp = j
j = k
k = temp
```

在同步分配时，未命名的元组在执行此类交换时隐式地充当临时变量。

在使用同步分配时，能简化代码的表达。我们重新思考在41页的生成fibonacci函数的生成器。这个传统的代码需要分开变量的出事值a和b。在每一步的循环中，目标值会重新分配a和b的值b与a+b。这时，我们完成需简单的使用第三个变量。在同步分配功能下，生成器能完成的更直接一点。：

```
def fibonacci():
    a,b = 0,1
    while :
        yield a
        a,b = b,a+b
```

 

1.10范围和名称空间

在python中，当计算算法x+y的和时，变量名x，y必须已经与值对象关联，如果发现未定义将返回NameError。将标示符关联到值的过程叫做名称转换。

当一个标示符指定到值时，定义在特定的空间内。高程度的分配是全范围的分配也可以在一个函数体的局部。因此，x=5在外界范围，对标示符x没有没有影响。

在python中每个不同的作用域都抽象的来表示名称空间。一个名称空间管理者所有的在个定范围内当前定义的标示符。图1.8描绘了两个命名空间。其中一个是1.5节的计数函数。另一个是函数执行过程中的局部命名空间。

![5](E:\github\data-structure\1.book\5.png)

Python用字典实现了名称空间，他的每一个字符串对应着一个值。Python提供了若干的方法检查名称空间。在命名空间中dir函数返回标识符的名字，这个函数的值返回的是字典。在默认情况下，调用dir（）和vars（）报告，在它们被执行的最本地封闭的名称空间中。

当标识符在函数中被引用。在名称解析过程中，python搜索一些列的名称空间。首先，对于给定的名字将在局部的空间搜索。如果没有搜索到，将在外面的空间继续搜索。在2.5节中，我们将继续命名空间的检查，那时会讨论python面向对象的处理。我们将看到每一个对象有他自己的名称空间储存他的属性，并且每一个类也有命名空间。

**一级对象：**

在编程语言的术语中，一级对象是能通过一个参数或者函数返回分配给标识符的例子。在1.2.3节中我们介绍的所有类型中，例如：整形、列表，在python中都是一级对象。在python中，函数和类也可以看做是一级对象。例如我们能这样写：

 ```
scream = print
scream('hello')
```



在这个例子中，我们没有创造新的函数，我们只是给scream简单地定义了一个自带的print函数。虽然这个例子没什么动机，但他展示了机器在python中一个参数能通过函数传递给另一个参数。在28页，我们注意到这个内置函数，max，当计算最大值时会接受一个无序的可选键值参数。例如，调用者可以使用语法max（a，b，key=abs）去判断那个值的绝对值更大。在这个函数体中，形式参数key是一个标识符，是分配真是的参数abs。

 在命名空间中，像scream=print这样的任务，将标识符引入到当前的命名空间，其值表示的是内置函数print。当宣布用户自定义函数时也使用相同的机制。例如，我们在1.5节的计数函数：

```
def count(data,target):
    ······
```

像这样的声明引入标识符count进入当前的命名空间，他的值就是完成这个函数的实例。同样，一个新定义的类的名字与该类的值得表现相关联。（类定义在下一个单元介绍）

### 1.11 模块和import

我们现在介绍了很多函数例如（max）和类例如：（list）。这些都定义在python的内置命名空间中。依赖着python的版本，这大约有130-150个非常重要的内置函数。

除了这些内置函数，python标准的发行版包括了数以千计的其他值、类都组织在额外的模块。这些模块都可以引进到一个程序。我们把math模块作为一个例子。内置的数学函数包括很少的数学函数。更多的数学函数都在math模块中。这个数学模块还定义了数学常数的近似值pi和e。

Python的import把一个模块加载到当前的命名空间。Import使用语法的形式像这样：

```from math import pi,sqrt```

这个命令把math模块中的pi和sqrt引入到当前的命名空间。并允许直接使用标示符调用这个函数。如果有许多函数需要从这一个模块引入，可以使用星号作为通配符：

```from math import *```

但是应该尽量少用这种方法。这种方法是很危险的，因为很有可能引入的函数名与已经存在的函数名冲突，这会导致新函数会代替已经存在的函数。

另一个方法能引入许多定义就是引入模块本身，使用语法如下：

```import math```

形式上，添加标示符math到当前的命名空间，适应模块作为值。（在python中模块也是一级对象）。一旦导入，单独的函数也可以从模块中使用完整的名字引入例如：suchas math.pi 或者 math.sqrt(2)。

**创建新模块**

要创建一个新模块，只需要将相关的模块放在以py结尾的文件中。这些定义能够在其他的py文件中引入。例如：如果我们把我们在1.5节定义的count函数放进名字为utility.py中，我们能使用相同的语法进入这个函数：fromutility import count

值得注意的是，当第一次导入模块时，带有模块源代码的顶级命令会执行的就像是模块是自己的脚本一样。这有一个特殊的结构，可以在模块中嵌入命令，如果模块直接作为脚本被调用，就会执行，担当模块从另一个脚本倒入，则不会执行。这样的命令应该放在条件语句中，：

```if __name__ = '__main__':```

以我们假设的utility.py模块为例，如果解释器是以python的utility.Py开始的那命令就会执行，除了utility模块引入了另外的内容。这种方法通常用于在模块中嵌入所谓的单元测试;我们将在2.2.4节中进一步讨论单元测试。

#### 1.11.1现有的模块

表1.7提供了学习数据结构一些经常使用的相关的模块。我们已经简单的讨论了math模块，在这节余下的部分，我们强调一些其他的模块，这些模块在这本书中对一些数据结构和算法是非常重要的。

![6](E:\github\data-structure\1.book\6.png)

**伪随机数生成**

Python的随机数生成了提供了一种能生成伪随机数的能力，也就是说数据是随机的(除了必须真实的随机数)。伪随机数生成器使用一个确定的公式，根据它生成的一个或多个过去的数字生成一个序列中的下一个数字。一个简单的伪随机生成器选择他的下一个数是基于最近常选择的单一的数和一些基础的参数，使用公式如下：

```next = (a*current + b)%n```

在这里a，b，n是经过适当选择的整数。Python使用了更先进的Mersenne twister技术。事实证明，这个技术产生的序列具有统计上的一致性，这是非常好的对于大部分需要岁技术的应用，例如：游戏。对于像电脑安全设置这需要无预测的随机0序列，这时这种公式不应该使用。相反，这是应该从一个资源中得到真的随机，例如：外太空发射的无线电。

在伪随机序列中第二个书是通过第一个数决定的，所以一个生成器需要一个起点，这个起点叫种子。这个数字序列如果给定相同的种子那生成的序列也是相同的。一个常用的窍门就是每一个程序运行使用一个种子，这样每次运行都会得到不同的序列。例如，我们可以使用当前的时间作为输入。

Python的随机模块对于通过定义random类生成伪随机数提供了支持，类的实例的服务作为生成器是独立的部分。这允许了一个项目的不同部分依靠着自己的伪随机数生成器，以至于调用一个生成器不影响其他已经生成的序列。为方便起见，随机类支持的所有方法也作为随机模块的独立函数支持。（基本使用一个生成器实例就能满足所有高层次的调用）

![7](E:\github\data-structure\1.book\7.png)