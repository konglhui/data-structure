# 2.4 继承

组织软件包的各种结构组件的一种自然方式是以分层方式进行的，具有类似的抽象定义，以层级方式分组在一起，从一个层次到另一个层次，从一个层次到另一个层次。图2.4展示了这样分层结构的例子。使用数学符号，房子是建筑的子集，但是是牧场的上级。这种层级对应关系总是使用‘is a’来表达这种关系。就像房子是一个建筑，牧场是一个房子。
![图2.4](C:\Users\Administrator\Desktop\微信图片_20180404105137.png)

分层设计在软件开发中非常有用，因为通用功能可以在最通用的层次上分组，因此可以促进代码的重用，而区分行为可以被看作是一般情况的扩展。在面向对象编程中，模块化和分级组织是一种被称为继承的技术。这允许一个新类一以已定义的类作为起点。在面向对象术语中，这种已存在的类叫做基础类、父类或上级类，新类叫子类会下级类。

子类有两种方式将它本身与父类区分开。一个子类可以通过对已存在的方法提供专门的实现方法。一个子类也可以对他的父类的新方法提供延展。

#### python的异常层次机构

另一个丰富的继承分层例子就是在python中组织各种各样的异常类型。在1.7节中我们介绍了很多这样的类，但是并没有讨论他们之间的关系。图2.5展示了分层的一部分。这个BaseException类是整个层次的根，这里大部分的异常类都包括了我们之前讨论的错误类型。欢迎程序员定义自己的特殊异常类来表示在应用程序中可能出现的错误。这些用户定义的异常类型应该声明为Exception的子类。
### 2.4.1 CreditCard类扩展
为了展示python中继承的机制，我们在回顾一下2.3节中的CreditCard类，去实现一个名为PredatoryCreditCard的子类。新类会与原始的两种方法有所不同，（1）如果费用因超出信用额度而被拒绝，则将收取5美元的费用，以及（2）将会有一种机制，用于根据年度百分比评估未结余额的月利息费用 Rate（APR）作为构造函数参数。

为了完成这个目标，我们使用了专业化和延展化的技术。为了收取无效费用的费用，我们覆盖了已经存在的收费方法，因此专门为他提供了新的功能（尽管新版本利用了对覆盖版本的调用。）为了收取利息，我们对类增加了一个名为process_month的新方法。
![图2.5](C:\Users\Administrator\Desktop\微信图片_20180404113946.png)

图2.6概述了我们在设计新的```PredatoryCreditCard```类时使用继承,代码片段 2.7给出了该类的完整Python实现。
```
class PredatoryCreditCard(CredirCard):
    """对CredietCard类的拓展增加利息和费用"""

    def __init__(self, customer, bank, acnt, limit, apr):
        '''
        创建一个新的信用卡类
        初始化余额为0
        '''
        super().__init__(customer, bank, acnt, limit)
        self._apr = apr

    def charge(self, price):
        '''
                如果有足够的信用额度，对卡收取一些费用，
        '''
        success = super().charge(price)
        if not success:
            self._balance += 5
        return success

    def process_month(self):
        '''每月收取未还费用的利息'''
        if self._balance > 0:
            # 如果余额为正，将APR转换为每月的乘法银子
            monthly_factor = pow(1 + self._apr, 1 / 12)
            self._balance *= monthly_factor
```

![图2.6](C:\Users\Administrator\Desktop\微信图片_20180404120044.png)

为了表明新类继承自现有的Credit Card类，我们的定义从语法类```PredatoryCreditCard（CreditCard）```开始。 新类的主体提供了三个成员函数：```__init__```，```charge```和```process month```。``` __init__```构造函数与原始```CreditCard```构造函数的作用非常相似，除了对于我们的新类，还有一个额外的参数来指定年度百分比率。 我们新的构造函数的主体依赖于调用继承的构造函数来执行大部分初始化（实际上除了记录百分比以外的所有内容）。 调用继承构造函数的机制依赖于语法```super()```。 具体来说，在第15行的命令```super(). __init__（customer，bank，acnt，limit）```调用从```CreditCard```超类继承的```__init__```方法。 注意这个方法只接受四个参数。 我们在名为```_apr```的新字段中记录apr值。

以此类推，我们的```PredatoryCreditCard```类提供了新的付费实现方式来覆盖继承的方法。然而新的实现方法依靠调用继承方法，调用语法```super().charge(price)```返回值是调用```charge```是否成功。我们检查返回值来决定是否收取费用，然后我们在将值返还给调用者，一边新版本的与原式版本一致。

这个```process_month```是一个新行为，这没有可以继承的版本。在我们的方法中，银行会每个月调用一次这个方法，添加新的利息费用给顾客的账户。实施这种方法最具挑战性的方面是确保我们对年度百分比率如何转换为每月费率有一定的了解。这并不是简单的将年利率除以12（这样的话，他的结果会很高）。正确的计算方法是1+```self._apr```的12次方根把它作为乘法因子。例如APR值为0.0825我们就要计算$$\sqrt[{12}]{{1.0825}} \approx 1.006628$$ ，因此利率是0.6628%每月。用着总方法，每100元每年获得利息为8.25元。
#### 保护成员

我们的```PredatoryCreditCard```子集能直接获取到```self._balance```的数据，她是通过```CreditCard```父类建立的。通常来说，强调的名称表明这是非公开成员，因此我们可能会问是否可以用这种方式访问它。对于这个类的普通用户是不能这样的，但子集与父集是有特权关系的。一些面向对象编程语言对于非公共成员进行区分，允许受保护的或特权声明进行访问。声明为受保护的成员可以被子类访问，但不能被公众访问，而被声明为私有的成员也不可访问。 在这方面，我们使用```_balance```就好像它受到保护（但不是私人的）。

Python不支持正式访问控制，但以单个下划线开头的名称通常与保护类似，而以双下划线开头的名称（非特殊方法）类似于私有名称。在选择使用受保护的数据时，我们创建了一个依赖关系，如果```CreditCard```类的作者要更改内部设计，我们的```PredatoryCreditCard```类可能会受到影响。注意，我们可以依靠公共的```get_balance()```方法来湖区当前的余额。但是```CreditCard```类的当前设计不能为子类改变余额提供有效的方式，除了直接操作数据成员。但是，该方法不允许余额超过客户的信用额度，即使银行可能会让利息超过信用额度（如果有必要）。 如果我们要重新设计原始的CreditCard类，那么我们可能会添加一个非公共方法```_set_balance```，它可以被子类用于影响更改而不直接访问数据成员```_balance```。

### 2.4.2 数字发展的层次结构






















