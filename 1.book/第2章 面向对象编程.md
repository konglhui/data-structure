# 第二章 面向对象编程
## 2.1 目标 原则和模式
顾名思义，在面向对象的过程中，对象就是主要的参与者。每个对象都是类的实例。每个类向外部世界展示一个简明的对象视图，这些对象是该类的实例。这个 过程不需要给出太多的细节也不需要让他人访问内部工作。类定义类型通常制定实例变量，也叫数据成员（也就是对象包含的成员）以及方法（也叫成员函数）对象可以执行。这种计算观点旨在实现几个目标并纳入我们在本章讨论的几个设计原则。
### 2.1.1 面向对象设计目标
设计软件应该包含鲁棒性、实用性和可重用性。

#### 鲁棒性

每一个程序员都行写出正确的软件，这就意味着一个程序在应用的过程中给一个预期的输入能输出。我们想让我们的软件具有鲁棒性就是让它有能力处理我们没有明确定义的输入类型。例如：如果一个程序的期望输入时正整数（可能是一个产品的价格）但是给了一个负整数。这个程序就应该有能力很好的回复这个错误。更重要的是，在医疗设备上如果没有鲁棒性，一个错误可能会导致受伤甚至丧失生命。在1980s发生的一个Therac-25事故中，一个放射性治疗设备给六个病人过重治疗，他们中的一些人由于放射性过重导致死亡。这六个事件都是因为软件错误。

#### 适用性
像浏览器和搜索引擎这种大型的现代软件都能使用很多年，因此软件要有能力多次进化去适应改变的外外界条件。因此另一个目标就是有适应能力（也叫可进化性）。与此相关的概念就是可移植性，就是一个软件有能力在不同的软件和操作系统中运行。python本身就有这种可移植性。
#### 可重用性
与可适用性同样重要的就是软件要有可重用性，就是相同的代码应该有能力在各种各样的应用中也能使用。卡法高性能的软件对企业来说是很昂贵的，如果这个软件可以在以后还能重用这样就可以抵消他的费用。可是然而，在Therac-25中，软件错误的主要来源之一是不恰当地重用Therac-20软件（它不是面向对象的，不是为使用Therac-25的硬件平台设计的）。
### 2.1.2面向对象设计原则
面向对象的过程中首要的原则就是为了下属的目标提供便利：
 - 模块化
 - 抽象化
 - 封装性
#### 模块化

现代的软件中包含了各种不同的组成，如果想让整个系统正常工作就必须要不同的部件正确的交互。保持这些交互的直接关系需要这些不同的组件组织得很好.模块化是一种组织原则，其中的不同部件划分成不同的功能单元。

做一个类比，一个房子或者公寓也能看做是不同的交互单元组成的：电、加热、冷却、管道和结构。与其把这些系统看成是一堆乱七八糟的电线、通风口管道和木板。还不如把他们看作是独立的模块，让他们以良好的方式交互工作。这样使用模块化能让思路很清晰，提供自然地组织函数给独立的管理单元。

像这样的方式在软件中使用模块化也能提供给强大的框架组织，从而为实现提供清晰的思路。在python中我们已经看到了模块是紧密相关的函数和类的集合，这些函数和类是在一个资源代码文件中一起定义的。例如：python标准库中包括了mah模块，提供了各种各样的数学内容和函数，还有os模块，提供了与操作系统的交互。
	 
模块化的使用能支持我们在2.1.1提出的目标。在他们集成一个大的系统之前，因为把不同的部件分开可以很容易的测试和调试，所以他的鲁棒性会大大的提高。而且，在一个完整的系统中持续存在的bug可以追溯到一个特定的组件，它可以在相对隔离的情况下被修复。模块化带来的结构也有助于软件的可重用性。如果软件模块是用一般的方式编写的，当相关需求在其他环境中出现时，模块可以被重用。这在数据结构研究中尤其重要，通常可以在许多应用程序中使用足够的抽象和通用性来设计。

#### 抽象化

抽象化就是将复杂的系统写成基本的系统。通常，描述系统的各个部分包括命名他们并解释他们的功能。应用这个抽象化去设计数据结构叫抽象数据类型（ADT）.一个ADT是一个数据指定的存储模式的结构的数学模型，并且支持操作和操作参数类型。ADT制定每个操作的应用，但不指定怎么做。我们通常会引用ADT作为公共接口支持的集体行为。
	
作为一个编程语言，python在接口方面提供了很大的自由度。python把抽象的传统隐含的使用了一个叫做duck类型的机制。作为一个解释器和动态类型语言，在python中没有对数据类型进行“编译时”检查，也没有对抽象基类声明的正式要求。相反的，程序员认为一个对象支持一致的行为，如果假定错误这个解释器会返回一个run-time错误类型。“duck typing”作为描述，这句话出自 James Whitcomb Riley诗人,是 “when I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”

更正式的，python通过抽象基类（ABC）的机制支持抽象数据类型，一个抽象基类不能实例化（你不能直接创造一个类的实例），但是他定义了一个或多个常见的抽象化实现的方法。 

一个ABC实现通过一个或多个具体的类，从抽象基类继承，同时为ABC声明的方法提供实现。python的abc模块提供了对ABC的支持，尽管为了简单起见，我们忽略了这样的声明。我们将利用来自Python的集合模块的几个现有的抽象基类，其中包括几个常见的数据结构的定义，以及一些抽象的具体实现。 
#### 封装化
面向对象的程序设计的另一个重要原则是封装化。一个软件系统的不同组成部分不应该展示他们实现过程的细节。封装化的主要优点是：他给了一个程序员自由的去实现这个组成的细节，而不用去关注其他程序员写的代码，这取决于内部的决定。对程序员唯一的约束就是维护组件的公共接口，其他程序员写代码必须依靠这个公共接口，封装化的鲁棒性和可重用性使它更容易去对局部进行修改错误和添加新的功能，由于它允许实现和修改程序的部分细节是不会对其他部件有所影响。

通过这本书，我们将坚持封装性的原则，清楚的说明数据结构的那些方面是公共的，那些事内部细节。pythoon仅仅支持宽松的可封装性。按照惯例，类成员的名称（包括数据成员和函数）是从下划线开始的（i.e _secret）认为是不公开的，并且是不值得信赖的。更强化了那些公约成员的故意遗漏自从生成文档。
### 2.1.3 设计模式
面向对象设计软件加强了可重用性，鲁棒性和可重用性。并且更简单的理解面向对象的方法对设计好的代码有很好的帮助。他需要更有效率的使用面向对象设计的技术。

计算机研究人员和实践者已经开发出了各种各样的组织概念和方法，用于设计简洁、正确和可重用的面向对象软件。与本书特别相关的是设计模式的概念，它描述了一个“典型”软件设计问题的解决方案。模式为解决方案提供了一个通用模板，可以在许多不同的情况下应用。它以一种抽象的方式描述解决方案的主要元素，该方法可以专门解决手边的特定问题。它由一个名称组成，它识别模式;上下文，它描述了这种模式可以应用的场景;一个模板，它描述了模式是如何应用的;结果，它描述和分析了模式产生的结果。

在这本书中我们提出了几种设计模式，我们也展示了他们是如何应用到数据结构和算法的实现过程。这些实际模型分成两个部分，一个是解决算法设计问题，另一个是解决软件工程问题。这些算法模式包括：	
 - 递归（第四章）
 - Amortization（5.3节和11.4节）
 - 分治法（12.2.1节）
 - Prune-and-search, also known as decrease-and-conquer (Section 12.7.1)
 -  Brute force (Section 13.2.1)
 - 动态程序设计（13.3节）
 - 贪心法（13.4.2节、14.6.2节和14.7节）
		 同样的：软件工程设计模型包括：
 - 迭代器（1.8节和2.3.4节）
 - 适配器（6.1.2节）
 - Position (Sections 7.4 and 8.1.2)
 - Composition (Sections 7.6.1, 9.2.1, and 10.1.4)
 - Template method (Sections 2.4.3, 8.4.6, 10.1.3, 10.5.2, and 11.2.1)
 - Locator (Section 9.5.1)
 -  Factory method (Section 11.2.1)

然而，我们并不是在这里解释每一个概念，而是在本文中介绍它们。对于每一个模式，无论是算法工程还是软件工程，我们解释它的一般用途，并且我们用至少一个具体的例子来说明它。
## 2.2 软件开发
传统的软件开发涉及到若干的步骤，三个主要的步骤是：
 - 设计
 - 实现
 - 测试和调试

在这一节，我们主要讨论这些阶段的作用，并且我们会介绍一些好的编程方法，包括代码风格，命名惯例，正式文档和测试单元
### 2.2.1 设计

对于面向对象编程，在整个开发软件的过程中设计的阶段可能是最重要的。因为在设计步骤中，我们决定了如何将程序的工作划分，我们决定这些类如何交互，数据如何存储以及每个行为的表现。这个最主要的挑战就是，程序员需要决定定义什么类来完成这个工作。通常处理这些问题是很难的，我们可以应用这些原则去决定怎么设计我们的类。

 - **职责**：把工作分成不同的角色，每一个都有不同的职责。试着用行为来描述这个职责。这些行为也将为程序创建类。
 - **独立性**：定义每一个类的功能做要尽可能的与其他类独立开。细分每一个类的职责让每一个类能对程序的一些部分有自主权。类对提供数据（作为变量实例）的行为要有管理的权限。
 - **行为**：为每一类精确而准确的定义这个行为，因此，一个类所执行的每一个操作的结果都将被其他与之交互的类所理解。这些行为是定义类的方法，而类的行为集是类的接口，因为这些方法为其他代码片段与来自类的对象交互。

把他们的实例变量和方法一起定义这个类是面向对象设计程序中设计的关键。一个好的程序员回花大量的时间开发更好的方法，因为经验告诉他要注意与他以前见过的模式相匹配的程序要求中的模式。

设计过程通过一个行为循环进行迭代，首先确定一个动作（即责任），然后确定最适合执行该动作的行为（即组件）。当我们为所有的动作都分配了行为时我们的设计就完成了。在使用卡片的过程中，我们依赖于每一个组成都应该有一个小的责任和合作者。执行这个规则有助于保持各个类的可管理性。

当设计成型时，解释和记录设计的标准方法是使用UML（统一建模语言）图来表示程序的组织。UML图表在表达面向队形设计软件是一个标准的视觉符号。一些计算机辅助工具可以建立UML图表。UML图的一种类型被称为类图。在图3.2中给的例图，一个类代表一张卡片。这个图有三个部分，第一个是类的名字，第二个记录着实例变量，第三个记录着类的方法。2.2.3节中我们讨论命名惯例，在2.3.1节中我们提供了基于此设计的Python CreditCard类的完整实现。
### 2.2.2 伪代码

作为实现设计之前的中间步骤，程序员经常被要求以仅用于人眼的方式来描述算法。 这种描述被称为伪代码。伪代码并不是计算机程序，但他的结构性更强。他混合了自然语言和高级程序结构去描述完成一个数据结构或者算法的主要想法。因为伪代码是写给人看的而不是计算机，我们只需要去交流想法而不是完成细节。同时，我们不应该隐藏重要的步骤，像许多人类沟通形式一样，找到适当的平衡是通过实践提炼出来的一项重要技能.

在这本书中，我们依靠着包含了数学符号和语言伪代码风格，希望对python程序员来说这是显而易见的。例如：我们使用一个短语“显示一个错误”然不是正式的raise声明。python的惯例，我们依靠缩进来指示控制结构的范围，以及索引符号，其中长度为n的序列A的条目从A [0]到A[n-1]被索引。在我们的伪代码中我们会把介绍放在{}里，而不是使用#号。
### 2.2.3 代码风格和文档

程序应该很容易去读和理解。因此，一个好的程序员要注意他们的代码风格，发展一种风格在程序设计的各个方面对人和电脑都是很重要的。在不同的程序社区有不同的代码风格。python的官方样式指南在：
[](http://www.python.org/dev/peps/pep-0008/)
	我们主要采用以下原则：
 - python代码块主要是四个空格，可是为了避免我们的代码块超出边缘，我们使用两个空格在每层缩进中。强烈建议避免使用tab，因为制表符在跨系统的不同宽度上显示，并且Python解释器不会将制表符和空格视为相同。许多python编辑器会自动的使用近似数量的空格来代替tab键。
 - 对标识符使用有意义的名称，尝试着使用能大声读出来的名字，选择能反应行为、原则或标识符数据的名字。

 - 类（除了python内置的类）应该有一个单数名词的名字。首字母应该大写。当多个单词在一起我们应该使用“CamelCase”让每一个单词首字母大写这种惯例，
 - 函数，包括类的函数应该是小写字母。如果多个单词结合他们应该用下划线分开，例如“make_payment”。函数的名称应该是描述其行为的动词。可是这个函数的目的是返回一个值，这个名字应该是一个名词去描述这个值。
 - 标识单个对象（例如，参数，实例变量或局部变量）的名称应该是小写名词（例如，价格）。 偶尔，当使用单个大写字母来指定数据结构的名称（如树T）时，我们会偏离此规则。
 - 传统上使用所有大写字母和下划线来分隔单词（例如MAX SIZE）来标识表示被认为是常量的值的标识符。
 回想一下我们关于封装的讨论，即在任何以单个前导下划线（例如，秘密）开头的上下文中的标识符旨在表明它们仅用于类或模块的“内部”使用，而不是公共接口的一部分。

 - 使用注释来添加一个程序的含义或者去解释这个结构。实时注释对快速理解很有帮助；在python中使用#号来表示：

```
if n%2 == 1: #n is odd
```
多行块注释适用于解释更复杂的代码段。 在Python中，这些技术上是多行字符串文字，通常用三引号（“”“）分隔，在执行时无效。 在下一节中，我们将讨论块注释的使用方法。
#### 文档

Python为直接嵌入正式文档提供了集成支持在源代码中使用称为文档字符串的机制。 形式上，作为模块，类或函数（包括类的成员函数）的主体内的第一条语句出现的任何字符串文字将被视为文档字符串。 按照惯例，这些字符串文字应该用三个引号（“““）分隔。 作为例子，我们第25页的比例函数版本可以记录下来。


```
def scale(data, factor):
”””Multiply all entries of numeric data list by the given factor.”””
	for j in range(len(data)):
		data[j] = factor
```
对于文档使用三引号字符串分隔符是很常见的，即使表述适合单行，如上例所示。 更详细的文档应该以总结目的的单一行开头，然后是空白行，然后是更多详细信息。 例如，我们可以更清楚地记录比例函数，如下所示：

```
def scale(data, factor):
”””Multiply all entries of numeric data list by the given factor.
data     an instance of any mutable sequence type (such as a list)
containing numeric elements
factor     a number that serves as the multiplicative factor for scaling
”””
	for j in range(len(data)):
		data[j] = factor
```

文档字符串存储为声明它的模块，函数或类的字段。 作为文档可以用各种方法检索。 例如，Python解释器中的help（x）命令会生成x相关的文档。 一个名为pydoc的外部工具，可用于生成正式的文档或网页。 编写有用文档的指南可在以下网址获得：[python 文档](https://www.python.org/dev/peps/pep-0257/)
在本书中，我们将尝试在空间允许的情况下呈现文档。 省略的文档可以在我们的源代码的在线版本中找到。
### 2.2.4 测试与调试
测试是实验检查程序正确性的过程。调试时跟中程序的执行过程，并发现其中的错误。在开发程序的过程中，测试和调试可能是最耗费时间的。
#### 测试
细致的测试计划是写程序的重要部分，虽然在所有可能的输入中验证程序的正确性通常是不可行的，但我们应该瞄准在有代表性的输入子集上执行程序。 至少，我们应该确保每个类的每个方法都至少测试一次（方法覆盖率）。更好的是，程序中的每个代码语句应至少执行一次（语句覆盖率）

程序经常在输入的特殊情况下失败。这种情况需要仔细鉴定和测试。例如，在测试排序（即按顺序）整数序列的方法时，我们应该考虑以下输入：
 - 这个序列长度可能为0
 - 这个序列有一个元素
 - 所有的元素都是一样的
 - 这个序列已经排序
 - 这个序列顺序是反的

除了特殊输入外，我们还应该考虑所用结构的特殊条件。例如，如果我们使用Python列表来存储数据，那么我们应该确保边界情况（例如在列表的开头或结尾处插入或删除）得到正确处理。

尽管使用手工制作的测试套件至关重要，但在随机生成的大量输入中运行该程序也是有利的。 Python中的随机模块提供了几种生成随机数的方法，或者用于随机化收集顺序。

程序的类和函数之间的依赖关系包括一个层次结构。 也就是说，如果A依赖于B，例如当函数A调用函数B时，或者函数A依赖于作为类B的实例的参数，则组件A在层次结构中的组件B之上。有两种主要的测试策略， 自上而下和自下而上，它们在测试组件的顺序上有所不同。

自顶向下的测试从程序层次的顶部到底部进行。 它通常与stubbing结合使用，boot-strapping技术用一个存根代替较低级别的组件，替代了模拟原始功能的组件。 例如，如果函数A调用函数B来获取文件的第一行，那么在测试A时，我们可以用一个存根来替换B，该存根返回一个固定的字符串。

自下而上的测试从较低级别的组件进行到较高级别的组件。 例如，首先测试不调用其他函数的底层函数，然后是仅调用底层函数的函数，依此类推。 类似地，不依赖任何其他类的类可以在另一个依赖于前者的类之前进行测试。 这种形式的测试通常被描述为单元测试，因为特定组件的功能是在独立于较大的软件项目的情况下进行测试的。 如果使用得当，该策略能更好地将错误原因与正在测试的组件进行隔离，因为它所依赖的低级组件应该已经过彻底测试。

Python为自动化测试提供了多种形式的支持。 在模块中定义函数或类时，可以将该模块的测试嵌入到同一个文件中。 第1.11节描述了这样做的机制。 在表单的条件结构中屏蔽的代码将在Python直接在该模块上调用时执行，
```
if name == __main__ :
# perform tests...
```
而不是在导入该模块以用于较大的软件项目时执行。 在这样的结构中放置测试是很常见的，用于测试该模块中专门定义的函数和类的功能。

Python的unittest模块为单元测试自动化提供了更强大的支持。 该框架允许将单个测试用例分组到更大的测试套件中，并为执行这些套件提供支持，并报告或分析这些测试的结果。 随着软件的维护，使用回归测试的行为，从而重新执行所有先前的测试，以确保对软件的更改不会在先前测试的组件中引入新的错误。
#### 调试
最简单的调试技术包括使用print语句在程序执行过程中跟踪变量的值。 这种方法的一个问题是最终打印语句需要被删除或注释掉，所以当软件最终发布时它们不会被执行。

更好的方法是在调试器中运行该程序，该调试器是用于控制和监视程序执行的专用环境。 调试器提供的基本功能是在代码中插入断点。 当程序在调试器内执行时，它会在每个断点处停止。 程序停止时，可以检查变量的当前值。

标准的Python发行版包含一个名为pdb的模块，该模块直接在解释器中提供调试支持。 大多数用于Python的IDE（如IDLE）都提供了带有图形用户界面的调试环境。
## 2.3 定义类

类在面向对象编程中抽象的主要手段。在python中，每一段数据都代表某些类的实例。一个类以成员函数（也称为方法）的形式提供一组行为，并且该类的所有实例都具有相同的实现。 一个类也可以作为其实例的蓝图，有效地确定每个实例的状态信息以属性（也称为字段，实例变量或数据成员）的形式表示的方式。
### 2.3.1 例子：CreditCard 类

作为第一个例子，我们提供了基于图2.3的一个CreditCard 类的实现。这个类的定义死通过CreditCard 类为传统的信用卡提供一个简单地模型。他们能识别顾客、银行等一些列信息。类限制可能导致卡片余额超过支出限额的费用，但不会收取利息或逾期付款（我们在2.4.1节重新讨论这些主题）

我们的代码在代码2.1和代码2.2，class是结构开始的关键字，后面是类的名字和冒号，然后是一个缩进的代码块作为类的结构。主体包括类定义的所有方法。这些方法使用函数定义（也就是在1.5节所介绍的），self是一个特殊的参数用来识别成员被调用的特定实例。
#### self 标识符

在python中，self标识符扮演者重要的角色。在上文中的CreditCard类，这可能有许多不同的类，每个人都必须保持自己保持平衡，自己的信用额度等等。因此，为了反映其当前状态每个实例都存储自己的实例变量。

在语法上，self标识调用方法的实例。 例如，假设我们的类的一个用户有一个变量，即我的卡，它标识了CreditCard类的一个实例。当用户调用my_card.get_balance（）时，在获取余额方法的定义中，标识符self指的是调用者称为我的卡。 余额是指一个实例变量，名为余额，作为该特定信用卡状态的一部分存储。self.balance是指一个实例变量，名为余额，作为该特定信用卡状态的一部分存储。
```
class CreditCard:
    '''用户信用卡'''

    def __init__(self, customer, bank, acnt, limit):
        ''' 创建一个新信用卡类。

        初期余额为0

        顾客	顾客的名字（e.g. ‘konglinghui’）
        银行	银行名字（e.g. ‘ zhongguobank ’）
        账户	账号号码（e.g ‘12341234124’）
        限制 	卡的限制（使用人民币）'''
        self._customer = customer
        self._bank = bank
        self._acount = acnt
        self._limit = limit
        self._balance = 0

    def get_customer(self):
        '''返回顾客的名字'''
        return self._customer

    def get_bannk(self):
        '''返回银行的名字'''
        return self._bank

    def get_account(self):
        '''返回银行卡账号'''
        return self._acount

    def get_limit(self):
        ''' 返回当前信用卡的限制'''
        return self._limit

    def get_blance(self):
        '''返回当前余额'''
        return self._balance

    def charge(self, price):
        '''假设有足够的信用额度，向卡收取价格。
                如果收费已处理，则返回True; 如果收费被拒绝，则为False'''
            if price + self._balance > self._limit:  # 如果收费超过限额
                return False  # 不能继续收费
            else:
                self._balance += price

    def make_payment(self, amount):
        """处理客户付款，减少额度 """
        self._balance -= amount
```
我们要注意在类中声明的方法签名与调用者使用的方法签名之间的区别。例如：从一个用户的角度来说我们能从get.balance中使用0这个参数。但在类定义中self是一个明确的变量。这个charge方法在具有两个参数（自我和价格）的类中声明，即使该方法被一个参数调用，例如，作为my_card.charge（200）。 解释器自动将调用该方法的实例绑定到self参数。
#### 构造函数
一个用户能使用如下的方法构造一个CreditCard类的实例。
```
cc = CreditCard('Jhn Doe','1st Bank','5309 2345 2345 4524',1000)
```

在内部，这会导致调用特定名称的init方法作为该类的构造函数。其主要职责是建立具有适当实例变量的新创建的信用卡对象的状态。在CreditCard类的情况下，每个对象都维护五个实例变量，我们将其命名为：客户，银行，账户，限额和余额。这五个中前四个的初始值被提供为用户在实例化信用卡时发送并在构造函数的主体内分配的显式参数。例如，命令，自我。 customer =customer，分配实例变量self。顾客给参数顾客;请注意，因为客户在右侧是不合格的，所以它指的是本地名称空间中的参数。根据第2.2.3节中所述的约定，以数据成员的名义（例如余额）为单位的前导下划线意味着它是非公开的。一个类的用户不应该直接访问这些成员。

按照惯例，所有的数据成员都是非公开的。他允许我们更好地为所有实例强制执行一致的状态。 我们可以提供访问者权限，比如get_balance，为类的用户提供对特征的只读访问权限。 如果我们希望允许用户更改状态，我们可以提供适当的更新方法。 在数据结构的背景下，封装内部表示我们可以更灵活地重新设计一个类的工作方式，或许可以提高结构的效率。
#### 附加的方法

在类中最有意思的行为是：charge和make——payment。 charge函数通常将给定价格添加到信用卡余额中，以反映客户购买所述价格。但是，在接受收费之前，我们的实施验证新购买不会导致余额超过信用额度。make_payment反映了客户向银行支付给定金额的付款，从而减少了卡上的余额。我们注意到这个命令是：self. balance −= amount。因为它表示卡的实例变量，所以余额用自身标识符限定，而不合格的数量表示本地参数。
#### 错误检查
我们写的CreditCard类鲁棒性不是很强，首先，我们注意到，我们没有明确检查要付费和付款的参数的类型，也没有检查构造函数的任何参数。 如果用户打电话visa.charge（糖果），我们的代码可能会崩溃，试图将该参数添加到当前的余额。如果这个类被广泛用于图书馆，我们可能会在面对这种误用时使用更严格的技术来引发TypeError（见第1.7节）。

除了明显的类型错误之外，我们的实现可能容易出现逻辑错误。 例如，如果允许用户收取负的价格，例如visa.charge（-300），这将有助于降低客户的余额。 这提供了一个漏洞，可以在不付款的情况下降低余额。 当然，如果对客户将商品退回商店时收到的信用进行建模，这可能会被视为有效用法。 我们将在章末练习中用CreditCard类探讨一些这样的问题。
#### 测试代码
在代码片段2.3中我们展示了一些CreditCard类的一些基础使用方法，在一个人的钱包中查了三张卡。我们使用循环做一些收款和花费，使用各种读写方式将结果打印出来。

这个测试包含以下条件，`if __name__ =='__main__':`让他们嵌入到类定义的的资源代码中。使用第2.2.4节的方法，这些测试提供了方法覆盖范围，因为每种方法至少被调用一次，但它不提供语句覆盖，因为从来没有因为信用而拒绝收费的情况 限制。 这不是测试的特殊先决条件，因为必须手动审计给定测试的输出以确定该类是否按预期行事。 Python有更多正式测试的工具（参见2.2.4节中关于测试单元模块的讨论），以便可以将结果值自动与预测结果进行比较，只有在检测到错误时才会生成输出。
```
if __name__ == '__main__':
    wallet = []
    wallet.append(CreditCard('John Bowman', 'California Savings',
                             '56 5391 0375 9387 5309', 2500))
    wallet.append(CreditCard('John Bowman', 'California Federal',
                             '58 3485 0399 3395 1954', 3500))
    wallet.append(CreditCard('John Bowman', 'California Finance',
                             '60 5391 0375 9387 5309', 5000))
    for val in range(1, 17):
        wallet[0].charge(val)
        wallet[1].charge(2 * val)
        wallet[2].charge(3 * val)

    for c in range(3):
        print('Customer=', wallet[c].get_customer())
        print('Bank=', wallet[c].get_bank())
        print('Account=', wallet[c].get_account())
        print('Limit=', wallet[c].get_limit())
        print('Balance=', wallet[c].get_balance())
        while wallet[c].get_balance() > 100:
            wallet[c].make_payment(100)
            print('New balance=', wallet[c].get_balance())
        print()
```
### 2.3.2 操作符重载和python的特殊方法
python的内置类提供了很多对自然语义处理的方法。例如：a+b就调用了数值加法来串联序列类型。当定义一个新类，当a或者b是一个类的实例的时候，我们必须考虑是否应该定义像a+b这样的语法。

通常，+操作符对于新类来说没有定义。然而，类的作者可以使用操作符重载的技术来定义。这是通过特殊的命名方法来完成的。+操作符是通过‘__add__'的方法来完成重载，他将右手操作数作为参数，并返回表达式的结构。语法a +b转换为表单a的对象a上的方法调用'a.__add__(b)'。对于其他操作符这种类似的明明方法也是存在的。表2.1提供了这种方法的列表。
![mark](http://p6yio0wew.bkt.clouddn.com/blog/180410/f519KEkjdF.png)
![mark](http://p6yio0wew.bkt.clouddn.com/blog/180410/Dc8aaC5B6C.png)

当两个不同类型的实例应用二元操作符时像:3*'Love me'，python会使用左边操作符的类。在这个例子中，它将有效地检查int类是否为如何通过mul方法将实例乘以一个字符串提供了足够的定义。如果这个类没有完成这个操作，python将检查左边操作符的类定义以一个名为rmu的特殊方法的形式（即：,“正确的“）。对于一个新的用户定义类提供了一个混合操作的方法，涉及到现有类的实例（假定现有的类没有定义涉及新类的行为）。在__mul__和__rmul__之间的区别是在一个实例中允许一个类定义不同的语义，例如：矩阵乘法这个操作符是不可以交换的。
#### 非运算符超载
当时用用户自定义类是，除了传统的运算符过载，python依靠不同的命名方法去控制其他方法的各种行为。例如：str(foo)正式的调用了str类的结构。如果参数是用户自定义类，string类的不知道该如何描述该实例。string会调用一个特殊的方法foo.__str__()这必须返回一个string代表。

类似的方法用于确定如何基于用户定义的类的参数构造int，float或bool。 转换为布尔值非常重要，因为foo不是形式上的布尔值，也可以使用语法if foo：（请参阅第1.4.1节）。对于用户定义的类，该条件由特殊方法foo.__bool__（）评估。

一些定义功能依靠调用特殊命名方法。例如：例如确定container类型大小的标准方法就是调用len（）函数。调用语法len(foo)，这并不是一个传统点操作符的调用语法。但是，在用户自定义类的例子中。len依靠的是一个特殊的__len__类的方法。这个调用len(foo)是相当于foo.__len__().当开始数据结构时，我们通常会定义__len__方法返回这个结构的尺寸。
#### 隐含方法

作为一般规则，如果特定的特殊方法未在用户定义的类中实现，则依赖于该方法的标准语法将引发异常。例如，对于没有__add__或__radd__的用户定义类的实例，评估表达式a + b将引发错误。

但是，有些操作符由Python提供缺省定义，在没有特殊方法的情况下，还有一些操作符的定义来自其他操作符。例如，__bool__方法支持'if foo:'语法，具有默认语义，因此除None之外的每个对象都评估为True。对于container类型，__len__方法是典型的返回container大小的定义。如果存在这样的方法，那么bool（foo）的求值对于非零长度的实例被默认解释为True，而对于零长度的实例则为False，允许使用诸如waitlist的语法：用于测试是否存在 是等候名单中的一个或多个条目。

在2.3.4节中，我们会讨论python的__iter__的特殊方法里面的迭代收集器的一个机制。如果一个容器类为__len__和__getitem__提供了实现，那么就会自动提供默认的迭代。而且，一旦定义了迭代器，就会默认的提供__contains__机制。

在1.3节中，我们讨论了`a is b`与`a == b`这两个表达式的区别，前面的是评估标示符a和b是否是同一个对象的别名。后者是测试两个标示符是否引用等价值得概念。可是，如果没有为__eq___给出实现，则语法`a == b`对于`a is b`是合法的，也就是说，一个实例等同于它本身没有其他实例。

我们应该注意到一些自然语义并不是python自动提供的。例如：__eq__方法提供了一个`a == b`语法，但是提供的方法并没有影响`a != b`语法的评估（这个__ne__语法是通过返回`not(a  == b)`语法的值提供的。类似的，__lt__对语法`a<b`提供了支持并且间接的支持了`b>a`，但是,__eq__与__lt__并不能提供`a<=b`的方法。

### 2.3.3 例子：多维向量类

通过特殊的方法去展示重载的使用方法，我们提供了向量类的实现，就是向量在多维空间的坐标。例如：在三维空间中，我们会用向坐标（5，-2，3）来代表一个向量。尽管这能直接使用python列表去代替这些坐标，列表并没有提供几何向量的近似抽象。如果使用列表，那么[5,-2,4]+[1,4,3]的结果就是[5,-2,4,1,4,3]。当向量u = [5,-2,4]与v = [1,4,3]想加后会返回一个三维向量（坐标是：[6,2,7])

在代码2.4中，我们定义了一个Vector类，对于集合向量的概念提供了更抽象的方法。在内部，向量依靠着一个列表的实例_coords作为存储机制。通过保持内部列表封装，可以的类执行所需要的公共接口。支持行为的实例为：
```
v = Vector(5)
v[1] = 23
v[-1] = 45
print(v[4])
u = v+v
print(u)
total = 0
for entry in v:
	total+=entry
```
我们通过频繁的调用相同的坐标列表来完成很多操作。并且，__add__的实现是自定义的。假设这两个操作数是相同长度的向量，这个方法能创造一个新的向量并设置新向量坐标来代表拉ing个操作数元素的和。

在代码2.4中，很有意思的是类定义自动支持语法`u = v + [5,3,10,-2,1]，这会产生一个新的向量，这个向量是第一个向量和列表实例的元素“总和”。这是python多态性的结果。字面上，“多态性”意味着“多种形式”。尽管很容易将我们的add方法的另一个参数想象成vector实例，但我们从来没有将它声明成这样。在本体中，我们唯一以来参数的行为是len（other）和其他[j]的访问。因此，当右侧的操作数是数字列表时我们的代码就会执行。

```
class Vector:
    '''在多元空间中代表向量'''

    def __init__(self, d):
        '''创建值为0的d维向量'''
        self._coords = [0] * d

    def __len__(self):
        '''返回向量的维数'''
        return len(self._coords)

    def __getitem__(self, j):
        '''返回第j坐标的值'''
        return self._coords[j]

    def __setitem__(self, j, val):
        '''在向量的第j个位置添加一个值'''
        self._coords[j] = val

    def __add__(self,other):
        '''返回两个向量的和'''
        if len(self) != len(other):
            raise ValueError('dimensions must agree')
        result = Vector(len(self))
        for j in range(len(self)):
            result[j] = self[j] + other[j]
        return result

    def __eq__(self, other):
        '''如果两个向量想等，就返回True'''
        return self._coords == other._coords

    def __ne__(self, other):
        '''如果两个向量不同，就返回True'''
        return not self == other

    def __str__(self):
        '''将向量转化为字符串'''
        return '<' + str(self._coords)[1:-1] + '>'
```

### 2.3.4 迭代器

在数据结构的设计中，迭代器是很重要的概念。在1.8节中，我们介绍了python迭代器的机制。简言之，一个集合迭代器提供了一个关键行为：他有一个__next__函数提供了返回集合中下一个元素的方法，如果没有元素了就会返回一个StopIteration的信号。

幸运的是，这很少直接完成一个迭代器的类。我们更喜欢直接使用generator语法（也在1.8节介绍过），它会自动生成一个生成值得迭代器。

python还每一个类提供了自动完成__len__和__getitem__的迭代。代码2.5展示了迭代器类提供__len__和__getitem__。这个类能用'SequenceIterator(data)'实例化。它通过保持对数据序列的内部参考以及序列中的当前索引来操作。每调用一次__next__,索引就会增加1，知道序列结束。
```
class SEquenceItertor:
	'''python任何类型的序列迭代器'''
	def __init__(self,sequence):
		'''通过给定的序列创造一个迭代器'''
		self._seq = sequence
		self._k = -1

	def __next__(self):
		'''返回下一个元素，或者返回StopIteration错误'''
		self._k += 1
		if self._k < len(self._seq):
			return (self._seq[self._k])
		else:
			raise StopIteration

	def __iter__(self):
		'''按照惯例，迭代器必须返回自身作为迭代器'''
		return self
```
### 2.3.5 例子：Range类

作为本节最后的一个例子，我们开发一个能完成python内置函数range类的实现。先介绍一下我们的类，先讨论内置版本的历史。在python3版本推出之前，range是作为函数实现的，他会返回一个列表实例。例如，'range(2,10,2'返回列表[2,4,6,8].可是，这个函数的典型用法是支持for循环语法，比如```for k in range(1000000)```.这就导致列表的实例和初始化含有一个数字序列。这是很没有必要的步骤，会导致时间和内存的滥用。

在python3中支持range的机制是非常不同的。他使用了一个叫做'lazy evaluation'的策略。range不是创建一个新的列表实例，而是一个类，它可以有效地表示所需的元素范围，而不需要将它们明确地存储在内存中。为了更好的探索内置range类，我们推荐你创造一个'r = range(8,140,5)'的实例。这个结果是相对轻量级的range类的实例，它有很少的行为。len(r)语法会返回给定的range里元素的个数。range函数也支持__geiitem__方法，所以，r[15]会返回range力第16个元素。因为类支持__len__和__getitem__，所以它继承了对迭代的自动支持（参见2.3.4节），这就是为什么可以在范围内执行for循环的原因。

此时此刻，我们正在展示饿哦们自己类的版本。代码2.6，Range类。实施中最大的挑战是正确计Range内的元素的数量，给定调用者在构建范围时发送的参数。通过计算构造函数中的值，把他储存在self._length()中，从'''__len__'''中返回会变得简单。为了正确的完成对'''__getitem__'''的调用,我们只需将范围的起始值加上步长的k倍（即对于k = 0，我们返回起始值）。 代码中有一些值得研究的细节：
- 为了正确支持可选参数，当讨论range的功能版本时，我们依赖于第27页中描述的技术。
- 我们计算在range中的元素数量使用max(0,(stop-start+step-1)//step).无论步长是整数还输负数都可以使用这个公式。
- 在计算结果之前，__getitem__方法通过将索引-k转换为len（self）-k来正确支持负数索引。
```
class Range:
    '''一个模仿内置range类的类'''

    def __init__(self, start, stop=None, step=1):
        '''初始化Range实例
        语义类似于内置Range类'''
        if step == 0:
            raise ValueError('step cannot be 0')

        if step is None:  # 特殊的例子range（n）
            start, stop = 0, start		# 应该作为range（0，n）

        # 计算长度
        self._length = max(0, (stop - start + step - 1) // step)
        # 需要了解开始和步长来支持__setitem__
        self._start = start
        self._step = step

    def __len__(self):
        '''返回range内储存的数量'''
        return self._length

    def __getitem__(self, k):
        '''返回在索引位置k的内容'''
        if k < 0:
            k = k + len(self)
        if not 0 <= k < self._length:
            raise IndexError('index out of range')

        return self._start + k * self._step
```

## 2.4 继承

组织软件包的各种结构组件的一种自然方式是以分层方式进行的，具有类似的抽象定义，以层级方式分组在一起，从一个层次到另一个层次，从一个层次到另一个层次。图2.4展示了这样分层结构的例子。使用数学符号，房子是建筑的子集，但是是牧场的上级。这种层级对应关系总是使用‘is a’来表达这种关系。就像房子是一个建筑，牧场是一个房子。
![mark](http://p6yio0wew.bkt.clouddn.com/blog/180410/9EDLHfFc2c.png)

分层设计在软件开发中非常有用，因为通用功能可以在最通用的层次上分组，因此可以促进代码的重用，而区分行为可以被看作是一般情况的扩展。在面向对象编程中，模块化和分级组织是一种被称为继承的技术。这允许一个新类一以已定义的类作为起点。在面向对象术语中，这种已存在的类叫做基础类、父类或上级类，新类叫子类会下级类。

子类有两种方式将它本身与父类区分开。一个子类可以通过对已存在的方法提供专门的实现方法。一个子类也可以对他的父类的新方法提供延展。

#### python的异常层次机构

另一个丰富的继承分层例子就是在python中组织各种各样的异常类型。在1.7节中我们介绍了很多这样的类，但是并没有讨论他们之间的关系。图2.5展示了分层的一部分。这个BaseException类是整个层次的根，这里大部分的异常类都包括了我们之前讨论的错误类型。欢迎程序员定义自己的特殊异常类来表示在应用程序中可能出现的错误。这些用户定义的异常类型应该声明为Exception的子类。
### 2.4.1 CreditCard类扩展
为了展示python中继承的机制，我们在回顾一下2.3节中的CreditCard类，去实现一个名为PredatoryCreditCard的子类。新类会与原始的两种方法有所不同，（1）如果费用因超出信用额度而被拒绝，则将收取5美元的费用，以及（2）将会有一种机制，用于根据年度百分比评估未结余额的月利息费用 Rate（APR）作为构造函数参数。

为了完成这个目标，我们使用了专业化和延展化的技术。为了收取无效费用的费用，我们覆盖了已经存在的收费方法，因此专门为他提供了新的功能（尽管新版本利用了对覆盖版本的调用。）为了收取利息，我们对类增加了一个名为process_month的新方法。
![mark](http://p6yio0wew.bkt.clouddn.com/blog/180410/L9lLclii7k.png)

图2.6概述了我们在设计新的```PredatoryCreditCard```类时使用继承,代码片段 2.7给出了该类的完整Python实现。
```
class PredatoryCreditCard(CredirCard):
    """对CredietCard类的拓展增加利息和费用"""

    def __init__(self, customer, bank, acnt, limit, apr):
        '''
        创建一个新的信用卡类
        初始化余额为0
        '''
        super().__init__(customer, bank, acnt, limit)
        self._apr = apr

    def charge(self, price):
        '''
                如果有足够的信用额度，对卡收取一些费用，
        '''
        success = super().charge(price)
        if not success:
            self._balance += 5
        return success

    def process_month(self):
        '''每月收取未还费用的利息'''
        if self._balance > 0:
            # 如果余额为正，将APR转换为每月的乘法银子
            monthly_factor = pow(1 + self._apr, 1 / 12)
            self._balance *= monthly_factor
```

![mark](http://p6yio0wew.bkt.clouddn.com/blog/180410/F1aeIaAG01.png)

为了表明新类继承自现有的Credit Card类，我们的定义从语法类```PredatoryCreditCard（CreditCard）```开始。 新类的主体提供了三个成员函数：```__init__```，```charge```和```process month```。``` __init__```构造函数与原始```CreditCard```构造函数的作用非常相似，除了对于我们的新类，还有一个额外的参数来指定年度百分比率。 我们新的构造函数的主体依赖于调用继承的构造函数来执行大部分初始化（实际上除了记录百分比以外的所有内容）。 调用继承构造函数的机制依赖于语法```super()```。 具体来说，在第15行的命令```super(). __init__（customer，bank，acnt，limit）```调用从```CreditCard```超类继承的```__init__```方法。 注意这个方法只接受四个参数。 我们在名为```_apr```的新字段中记录apr值。

以此类推，我们的```PredatoryCreditCard```类提供了新的付费实现方式来覆盖继承的方法。然而新的实现方法依靠调用继承方法，调用语法```super().charge(price)```返回值是调用```charge```是否成功。我们检查返回值来决定是否收取费用，然后我们在将值返还给调用者，一边新版本的与原式版本一致。

这个```process_month```是一个新行为，这没有可以继承的版本。在我们的方法中，银行会每个月调用一次这个方法，添加新的利息费用给顾客的账户。实施这种方法最具挑战性的方面是确保我们对年度百分比率如何转换为每月费率有一定的了解。这并不是简单的将年利率除以12（这样的话，他的结果会很高）。正确的计算方法是1+```self._apr```的12次方根把它作为乘法因子。例如APR值为0.0825我们就要计算$$\sqrt[{12}]{{1.0825}} \approx 1.006628$$ ，因此利率是0.6628%每月。用着总方法，每100元每年获得利息为8.25元。
#### 保护成员

我们的```PredatoryCreditCard```子集能直接获取到```self._balance```的数据，她是通过```CreditCard```父类建立的。通常来说，强调的名称表明这是非公开成员，因此我们可能会问是否可以用这种方式访问它。对于这个类的普通用户是不能这样的，但子集与父集是有特权关系的。一些面向对象编程语言对于非公共成员进行区分，允许受保护的或特权声明进行访问。声明为受保护的成员可以被子类访问，但不能被公众访问，而被声明为私有的成员也不可访问。 在这方面，我们使用```_balance```就好像它受到保护（但不是私人的）。

Python不支持正式访问控制，但以单个下划线开头的名称通常与保护类似，而以双下划线开头的名称（非特殊方法）类似于私有名称。在选择使用受保护的数据时，我们创建了一个依赖关系，如果```CreditCard```类的作者要更改内部设计，我们的```PredatoryCreditCard```类可能会受到影响。注意，我们可以依靠公共的```get_balance()```方法来湖区当前的余额。但是```CreditCard```类的当前设计不能为子类改变余额提供有效的方式，除了直接操作数据成员。但是，该方法不允许余额超过客户的信用额度，即使银行可能会让利息超过信用额度（如果有必要）。 如果我们要重新设计原始的CreditCard类，那么我们可能会添加一个非公共方法```_set_balance```，它可以被子类用于影响更改而不直接访问数据成员```_balance```。

### 2.4.2 数字发展的层次结构

继承用法的第二个例子是开发一个用于迭代数字进展类的继承。一个数字进程是一串数字序列，每一个数字都是依靠着前一个或多个数字构成的。例如等差数列、等比数列。通常一个数列需要一个初始值和一个通项公式。

为了最大化代码的可重用性，从通用的基类那里开发了一个类的层次结构，并命名为`Progress`（见图2.7）。这个`Progress`类生成了整个数值：0,1,2，……但是这个类设计的目的是为其他数列服务的，并尽可能的提供能量，从而减轻类的负担。

![mark](http://p6yio0wew.bkt.clouddn.com/blog/180410/72aBkk0idk.png)

我们在代码2.8中完成了这个基础类Progress。的构造函数接受进程的初始值（默认为0），并初始化将值赋予给数据成员`self._current`。

这个Progress类实现了python迭代器里的`__next__`和`__iter__`两个通常会出现的类。如果类的使用者创建了一个`seq = Progress()`语句，每调用一次next（seq）都会返回seq序列的下一个元素。它可以使用for循环语法`for value in seq`但要注意现在默认的序列是一个无限的长度。

为了更好地将迭代器的机制与序列步骤的核心逻辑分开，我们的框架是依靠着自身一个叫`_advance`方法来更新`self._current`的值。默认是值加1，但我们的想法是自己会覆盖掉`_advance`来提供一个不一样的算法。

为了方便，Progress类提供一个很有用的打印算法，他会打印出下n个序列的值。

```
class Progression:
	'''迭代器会生成一个通用序列，默认这个迭代器是生成整个数组 0,1,2，……'''
	def __init__(self,start = 0):
		'''初始化当前序列的第一个值'''
		self._current = start

	def _advance(self):
		''' 为self._current赋予一个新值

		这应该由子类重写以自定义进程。

		按照惯例，如果current为0，这表示有限进程的结束。'''
		self._current += 1

	def __next__(self):
		'''返回下一个元素，或者返回StopIteration'''
		if self._current is None:
			raise StopIteration()

		else:
			answer = self._current
			self._advance()
			return answer

	def __iter__(self):
		'''通常，迭代器必须返回它本身'''
		return self

	def print_progression(self,n):
		'''打印下n个数列的值'''
		print(' ',join(str(next(self))for i in range(n)))
```

#### 等差数列类












